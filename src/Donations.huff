/** 
 *  DONATIONS HUFF EXERCISE
 *  
 *  The task is to Implement solidity's "receive" functionality which allows sending ether to a smart contract without any calldata
 *  also have a getter function that returns how much an address has donated. Addresses can donate several times
 */

#define function donated(address) payable returns(uint256)

#define macro MAIN() = takes(0) returns(0) {
    calldatasize
    iszero
    receive_def jumpi
    0x00 calldataload
    0xE0 shr
    __FUNC_SIG(donated)
    eq
    donated_def jumpi
    0x00 0x00 revert

    receive_def:
        caller              // [caller]
        0x00 mstore         // []
        0x20 0x00 sha3      // [sha3(caller)]
        dup1                // [sha3(caller), sha3(caller)]
        sload               // [caller_donated, sha3(caller)]
        callvalue add       // [new_caller_donated, sha3(caller)]
        swap1               // [sha3(caller), new_caller_donated]
        sstore              // []
        stop

    donated_def:
        caller              // [caller]
        0x00 mstore         // []
        0x20 0x00 sha3      // [sha3(caller)]
        sload               // [caller_donated]
        0x00 mstore         // []
        0x20 0x00 return    // []
}